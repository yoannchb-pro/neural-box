{"version":3,"file":"index.js","sources":["../../neural-box/src/network/NeuralNode.ts","../../neural-box/src/utils/randomUniform.ts","../../neural-box/src/neat/NeatAlgo.ts","../../neural-box/src/network/Connection.ts","../../neural-box/src/network/Network.ts","../../neural-box/src/utils/sigmoid.ts","../src/game/Sprite.ts","../src/game/velocity.ts","../src/game/Base.ts","../src/game/Background.ts","../src/game/Pipe.ts","../src/game/Bird.ts","../src/game/Score.ts","../src/index.ts","../../neural-box/src/utils/drawNeuralNetwork.ts"],"sourcesContent":["export enum NodeType {\n  HIDDEN,\n  INPUT,\n  OUTPUT,\n  BIAS\n}\n\nexport type NeuralNodeJson = {\n  id: number;\n  layer: number;\n  nodeType: NodeType;\n};\n\ntype ConstructorProps = {\n  id: number;\n  layer: number;\n  nodeType: NodeType;\n};\n\nexport class NeuralNode {\n  public id: number;\n  public output = 0;\n  public nodeType: NodeType;\n  public layer: number;\n\n  constructor(params: ConstructorProps) {\n    this.id = params.id;\n    this.nodeType = params.nodeType;\n    this.layer = params.layer;\n    if (this.nodeType === NodeType.BIAS) this.output = 1;\n  }\n\n  toJson(): NeuralNodeJson {\n    return {\n      id: this.id,\n      layer: this.layer,\n      nodeType: this.nodeType\n    };\n  }\n\n  clone() {\n    const copy = new NeuralNode({\n      id: this.id,\n      layer: this.layer,\n      nodeType: this.nodeType\n    });\n    return copy;\n  }\n}\n","/**\n * Uniform distribution of a random number in a range\n * @param min\n * @param max\n * @returns\n */\nexport function randomUniform(min: number, max: number): number {\n  return Math.random() * (max - min) + min;\n}\n","import { Network } from '../network/Network';\nimport { NodeType } from '../network/NeuralNode';\nimport { randomUniform } from '../utils/randomUniform';\n\ntype ConstructorParams = {\n  mutationsChances?: {\n    newConnection?: number;\n    newNode?: number;\n    weightModification?: number;\n    removeNode?: number;\n    disableConnection?: number;\n    enableConnection?: number;\n  };\n};\n\nconst defaultMutationsChances: Required<ConstructorParams['mutationsChances']> = {\n  disableConnection: 0.1,\n  enableConnection: 0.1,\n  newConnection: 0.1,\n  newNode: 0.1,\n  removeNode: 0.1,\n  weightModification: 0.9\n};\n\nexport class NeatAlgo {\n  private mutationsChances: Required<Required<ConstructorParams>['mutationsChances']>;\n\n  constructor(params: ConstructorParams = {}) {\n    this.mutationsChances = Object.assign({}, defaultMutationsChances, params.mutationsChances);\n  }\n\n  crossover() {}\n\n  mutate(network: Network) {\n    const connections = network.getConnections();\n    const nodes = network.getNodes();\n\n    // Weight modification\n    if (Math.random() <= this.mutationsChances.weightModification && connections.length > 0) {\n      const rndConnection = Math.floor(randomUniform(0, connections.length));\n      const [minWeight, maxWeight] = network.getWeightRange();\n      const newWeight = randomUniform(minWeight, maxWeight);\n      connections[rndConnection].weight = newWeight;\n    }\n\n    // New connection\n    if (Math.random() <= this.mutationsChances.newConnection) {\n      network.addRandomConnection();\n    }\n\n    // New hidden node\n    if (Math.random() <= this.mutationsChances.newNode && connections.length > 0) {\n      const rndConnection = Math.floor(randomUniform(0, connections.length));\n      network.addNodeInConnection(connections[rndConnection]);\n    }\n\n    // Remove hidden node\n    if (Math.random() <= this.mutationsChances.removeNode && nodes.length > 0) {\n      const removableNodes = nodes.filter(node => node.nodeType === NodeType.HIDDEN);\n      if (removableNodes.length > 0) {\n        const rndNode = Math.floor(randomUniform(0, removableNodes.length));\n        network.removeNode(removableNodes[rndNode]);\n      }\n    }\n\n    // Disable connection\n    if (Math.random() <= this.mutationsChances.disableConnection && connections.length > 0) {\n      const noBiasConnections = connections.filter(\n        con => con.from.nodeType !== NodeType.BIAS && con.to.nodeType !== NodeType.BIAS\n      );\n\n      if (noBiasConnections.length > 0) {\n        const rndConnection = Math.floor(randomUniform(0, noBiasConnections.length));\n        noBiasConnections[rndConnection].enabled = false;\n      }\n    }\n\n    // Enable connection\n    if (Math.random() <= this.mutationsChances.enableConnection) {\n      const disabledConnections = connections.filter(connection => !connection.enabled);\n\n      const noBiasDisabledConnections = disabledConnections.filter(\n        con => con.from.nodeType !== NodeType.BIAS && con.to.nodeType !== NodeType.BIAS\n      );\n\n      if (noBiasDisabledConnections.length > 0) {\n        const rndConnection = Math.floor(randomUniform(0, noBiasDisabledConnections.length));\n        noBiasDisabledConnections[rndConnection].enabled = true;\n      }\n    }\n  }\n\n  generateChildrens(networks: Network[], numberOfChildrens: number): Network[] {\n    const childrens: Network[] = [];\n\n    for (let i = 0; i < numberOfChildrens; ++i) {\n      // TODO\n    }\n\n    return childrens;\n  }\n}\n","import { randomUniform } from '../utils/randomUniform';\nimport type { NeuralNode } from './NeuralNode';\n\ntype ConstructorProps = {\n  from: NeuralNode;\n  to: NeuralNode;\n  weight?: number;\n  weightRange?: [number, number];\n};\n\nexport type ConenctionJson = {\n  innovationNumber: number;\n  fromId: number;\n  toId: number;\n  weight: number;\n  enabled: boolean;\n};\n\nclass InnovationNumberManager {\n  private static currentInnovationNumber = 0;\n  private static innovationHistory: Map<string, number> = new Map();\n\n  static getInnovationNumber(fromNodeId: number, toNodeId: number): number {\n    const key = `${fromNodeId}-${toNodeId}`;\n\n    if (this.innovationHistory.has(key)) {\n      return this.innovationHistory.get(key)!;\n    }\n\n    const newInnovationNumber = this.currentInnovationNumber++;\n    this.innovationHistory.set(key, newInnovationNumber);\n    return newInnovationNumber;\n  }\n}\n\nexport class Connection {\n  public innovationNumber: number;\n\n  public from: NeuralNode;\n  public to: NeuralNode;\n  public weight: number;\n  public enabled = true;\n\n  public static DEFAULT_WEIGHT_RANGE = [-0.5, 0.5];\n\n  constructor(params: ConstructorProps) {\n    this.innovationNumber = InnovationNumberManager.getInnovationNumber(\n      params.from.id,\n      params.to.id\n    );\n    this.from = params.from;\n    this.to = params.to;\n    this.weight =\n      params.weight ??\n      randomUniform(\n        params.weightRange?.[0] ?? Connection.DEFAULT_WEIGHT_RANGE[0],\n        params.weightRange?.[1] ?? Connection.DEFAULT_WEIGHT_RANGE[1]\n      );\n  }\n\n  toJson(): ConenctionJson {\n    return {\n      innovationNumber: this.innovationNumber,\n      enabled: this.enabled,\n      fromId: this.from.id,\n      toId: this.to.id,\n      weight: this.weight\n    };\n  }\n\n  clone() {\n    const copy = new Connection({\n      from: this.from,\n      to: this.to,\n      weight: this.weight\n    });\n    copy.enabled = this.enabled;\n    return copy;\n  }\n}\n","import { randomUniform } from '../utils/randomUniform';\nimport { sigmoid } from '../utils/sigmoid';\nimport { ConenctionJson, Connection } from './Connection';\nimport { NeuralNode, NeuralNodeJson, NodeType } from './NeuralNode';\n\nexport type NetworkJson = {\n  inputLength: number;\n  outputLength: number;\n  hiddenLength: number[];\n  hiddenLayers: number;\n  weightRange?: [number, number];\n\n  connections: ConenctionJson[];\n  nodes: NeuralNodeJson[];\n};\n\ntype ConstructorProps = {\n  inputLength: number;\n  outputLength: number;\n  hiddenLength?: number[];\n  hiddenLayers?: number;\n\n  weightRange?: [number, number];\n};\n\nexport class Network {\n  public currentNodeId = 0;\n\n  public fitness: number = 0;\n\n  private inputLength: number;\n  private outputLength: number;\n  private hiddenLength: number[];\n  private hiddenLayers: number;\n\n  private weightRange: ConstructorProps['weightRange'];\n\n  public connections: Connection[] = [];\n  public nodes: NeuralNode[] = [];\n\n  constructor(params: ConstructorProps) {\n    this.inputLength = params.inputLength;\n    this.outputLength = params.outputLength;\n\n    this.weightRange = params.weightRange;\n\n    if (params.hiddenLength && params.hiddenLength.length !== params.hiddenLayers) {\n      throw new Error(\n        `Invalide parameter \"hiddenLength\": ${params.hiddenLength.length} (should be an array of the same size as \"hiddenLayers\": ${params.hiddenLayers}).`\n      );\n    }\n\n    this.hiddenLayers = params.hiddenLayers ?? 0;\n    this.hiddenLength = params.hiddenLength ?? [];\n  }\n\n  static fromJson(json: NetworkJson): Network {\n    const network = new Network({\n      inputLength: json.inputLength,\n      outputLength: json.outputLength,\n      hiddenLayers: json.hiddenLayers,\n      hiddenLength: json.hiddenLength,\n      weightRange: json.weightRange\n    });\n\n    let maxId = 0;\n    for (const node of json.nodes) {\n      network.nodes.push(\n        new NeuralNode({\n          id: node.id,\n          layer: node.layer,\n          nodeType: node.nodeType\n        })\n      );\n      maxId = Math.max(maxId, node.id);\n    }\n\n    network.currentNodeId = maxId;\n\n    for (const connection of json.connections) {\n      const from = network.nodes.find(n => n.id === connection.fromId)!;\n      const to = network.nodes.find(n => n.id === connection.toId)!;\n      const con = new Connection({\n        from,\n        to,\n        weight: connection.weight,\n        weightRange: json.weightRange\n      });\n      network.connections.push(con);\n    }\n\n    return network;\n  }\n\n  toJson(): NetworkJson {\n    return {\n      connections: this.connections.map(c => c.toJson()),\n      hiddenLayers: this.hiddenLayers,\n      hiddenLength: this.hiddenLength,\n      inputLength: this.inputLength,\n      nodes: this.nodes.map(n => n.toJson()),\n      outputLength: this.outputLength,\n      weightRange: this.weightRange\n    };\n  }\n\n  /**\n   * Generate the full network with all connections and all nodes\n   */\n  generateFullNetwork() {\n    let nodesOfPrecedentLayer: NeuralNode[] = [];\n\n    // Input bias\n    const bias = new NeuralNode({\n      id: ++this.currentNodeId,\n      layer: 0,\n      nodeType: NodeType.BIAS\n    });\n    nodesOfPrecedentLayer.push(bias);\n    this.nodes.push(bias);\n\n    // Inputs\n    for (let i = 0; i < this.inputLength; ++i) {\n      const input = new NeuralNode({\n        id: ++this.currentNodeId,\n        layer: 0,\n        nodeType: NodeType.INPUT\n      });\n      nodesOfPrecedentLayer.push(input);\n      this.nodes.push(input);\n    }\n\n    for (let i = 0; i < this.hiddenLayers; ++i) {\n      const layer = i + 1;\n\n      const hiddenLength = this.hiddenLength[i];\n      // Hidden bias\n      const bias = new NeuralNode({\n        id: ++this.currentNodeId,\n        layer,\n        nodeType: NodeType.BIAS\n      });\n      const hiddenCreatedNodes: NeuralNode[] = [bias];\n\n      for (let j = 0; j < hiddenLength; ++j) {\n        const hidden = new NeuralNode({\n          id: ++this.currentNodeId,\n          layer,\n          nodeType: NodeType.HIDDEN\n        });\n\n        // We create the connection with the precedents nodes\n        for (const precedentLayerNode of nodesOfPrecedentLayer) {\n          const connection = new Connection({\n            from: precedentLayerNode,\n            to: hidden,\n            weightRange: this.weightRange\n          });\n          this.connections.push(connection);\n        }\n\n        hiddenCreatedNodes.push(hidden);\n        this.nodes.push(hidden);\n      }\n\n      nodesOfPrecedentLayer = hiddenCreatedNodes;\n    }\n\n    for (let i = 0; i < this.outputLength; ++i) {\n      const output = new NeuralNode({\n        id: ++this.currentNodeId,\n        layer: this.hiddenLayers + 1,\n        nodeType: NodeType.OUTPUT\n      });\n\n      // We create the connection with the precedents nodes\n      for (const precedentLayerNode of nodesOfPrecedentLayer) {\n        const connection = new Connection({\n          from: precedentLayerNode,\n          to: output,\n          weightRange: this.weightRange\n        });\n        this.connections.push(connection);\n      }\n\n      this.nodes.push(output);\n    }\n  }\n\n  /**\n   * Calculate the output for a specific input\n   * @param inputs\n   * @returns\n   */\n  input(inputs: number[]): number[] {\n    if (inputs.length !== this.inputLength) {\n      throw new Error('Number of inputs must match the number of \"inputLength\".');\n    }\n\n    const inputNodes: NeuralNode[] = [];\n    const outputNodes: NeuralNode[] = [];\n    const inputsToCalculates: NeuralNode[] = [];\n\n    for (const node of this.nodes) {\n      switch (node.nodeType) {\n        case NodeType.INPUT:\n          inputNodes.push(node);\n          break;\n        case NodeType.OUTPUT:\n          outputNodes.push(node);\n          break;\n      }\n\n      if (node.nodeType !== NodeType.BIAS && node.nodeType !== NodeType.INPUT) {\n        inputsToCalculates.push(node);\n      }\n    }\n\n    // We reset the hiddens/output nodes\n    for (const inputToReset of inputsToCalculates) {\n      inputToReset.output = 0;\n    }\n\n    // We set the inputs node with the correct input value\n    for (let i = 0; i < inputNodes.length; ++i) {\n      inputNodes[i].output = inputs[i];\n    }\n\n    // For each connection we accumulate their contribution to the neuron\n    // A neuron can have multiple entry connection this is why its an addition\n    for (const connection of this.connections) {\n      if (!connection.enabled) continue;\n\n      const nodeDest = connection.to;\n      const contribution = connection.from.output * connection.weight;\n      nodeDest.output += contribution;\n    }\n\n    // After we have accumulate the connection contribution to the neuron we add the bias\n    // Then we apply the transformation function (expl: sigmoid)\n    for (const node of inputNodes) {\n      node.output = sigmoid(node.output);\n    }\n\n    return outputNodes.map(node => node.output);\n  }\n\n  /**\n   * Remove a specific connection\n   * @param connection\n   */\n  removeConnection(connection: Connection) {\n    const index = this.connections.findIndex(co => connection === co);\n    if (index !== -1) this.connections.splice(index, 1);\n  }\n\n  /**\n   * Remove a node\n   * @param node\n   */\n  removeNode(node: NeuralNode) {\n    this.nodes = this.nodes.filter(n => n !== node);\n    this.connections = this.connections.filter(conn => conn.from !== node && conn.to !== node);\n  }\n\n  /**\n   * Add a node in between a connection\n   * @param connection\n   */\n  addNodeInConnection(connection: Connection) {\n    this.removeConnection(connection);\n\n    const newNode = new NeuralNode({\n      id: ++this.currentNodeId,\n      layer: connection.from.layer + 1,\n      nodeType: NodeType.HIDDEN\n    });\n\n    this.nodes.push(newNode);\n\n    const connectionToNewNode = new Connection({\n      from: connection.from,\n      to: newNode,\n      weightRange: this.weightRange\n    });\n\n    const connectionFromNewNode = new Connection({\n      from: newNode,\n      to: connection.to,\n      weightRange: this.weightRange\n    });\n\n    this.connections.push(connectionToNewNode, connectionFromNewNode);\n  }\n\n  /**\n   * Add a random connection\n   * @returns\n   */\n  addRandomConnection() {\n    let attemptCount = 0;\n    const maxAttempts = this.nodes.length * this.nodes.length; // A simple upper limit based on the number of possible connections\n\n    while (attemptCount < maxAttempts) {\n      const fromIndex = Math.floor(randomUniform(0, this.nodes.length));\n      const toIndex = Math.floor(randomUniform(0, this.nodes.length));\n\n      if (fromIndex === toIndex) {\n        attemptCount++;\n        continue;\n      }\n\n      const from = this.nodes[fromIndex];\n      const to = this.nodes[toIndex];\n\n      const connectionExist = this.connections.some(\n        con => con.from.id === from.id && con.to.id === to.id\n      );\n\n      if (connectionExist || from.layer === to.layer) {\n        attemptCount++;\n        continue;\n      }\n\n      const randomConnection = new Connection({\n        from,\n        to,\n        weightRange: this.weightRange\n      });\n\n      const exists = this.connections.some(\n        connection =>\n          connection.from === randomConnection.from && connection.to === randomConnection.to\n      );\n\n      if (!exists) {\n        this.connections.push(randomConnection); // Assuming this.connections is the array holding all connections\n        return randomConnection;\n      }\n\n      attemptCount++;\n    }\n\n    throw new Error('Failed to add a new connection: too many attempts.');\n  }\n\n  getWeightRange() {\n    return this.weightRange ?? Connection.DEFAULT_WEIGHT_RANGE;\n  }\n\n  getConnections() {\n    return this.connections;\n  }\n\n  getNodes() {\n    return this.nodes;\n  }\n\n  setConnections(connections: Connection[]) {\n    this.connections = connections;\n  }\n\n  setNodes(nodes: NeuralNode[]) {\n    this.nodes = nodes;\n  }\n\n  /**\n   * Clone the current network\n   * @returns\n   */\n  clone() {\n    const copy = new Network({\n      inputLength: this.inputLength,\n      outputLength: this.outputLength,\n      hiddenLayers: this.hiddenLayers,\n      hiddenLength: this.hiddenLength,\n      weightRange: this.weightRange\n    });\n\n    copy.currentNodeId = this.currentNodeId;\n\n    const nodesCopy = [...this.getNodes().map(node => node.clone())];\n    copy.setNodes(nodesCopy);\n\n    const connectionsCopy = [\n      ...this.getConnections().map(connection => {\n        const clone = connection.clone();\n        clone.from = nodesCopy.find(n => n.id === clone.from.id)!;\n        clone.to = nodesCopy.find(n => n.id === clone.to.id)!;\n        return clone;\n      })\n    ];\n    copy.setConnections(connectionsCopy);\n\n    return copy;\n  }\n}\n","/**\n * Sigmoid function to turn any number into the range from 0 to 1\n * Usefull for probability\n * @param x\n * @returns\n */\nexport function sigmoid(x: number): number {\n  return 1 / (1 + Math.exp(-x));\n}\n","export class Sprite {\n  public sprite: HTMLImageElement = new Image();\n\n  constructor(src: string) {\n    this.sprite.src = `./sprites/${src}`;\n  }\n}\n","export const velocity = 4;\n","import { Sprite } from './Sprite';\nimport { velocity } from './velocity';\n\ntype ConstructorProps = {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n};\n\nconst BASE_SPRITE = new Sprite('base.png').sprite;\n\nexport class Base {\n  private x = 0;\n\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  public static BASE_SIZE = 100;\n\n  constructor(params: ConstructorProps) {\n    this.canvas = params.canvas;\n    this.ctx = params.ctx;\n  }\n\n  update() {\n    this.x -= velocity;\n    if (this.x <= -this.canvas.width) this.x = 0;\n  }\n\n  draw() {\n    this.ctx.drawImage(\n      BASE_SPRITE,\n      this.x,\n      this.canvas.height - Base.BASE_SIZE,\n      this.canvas.width,\n      Base.BASE_SIZE\n    );\n\n    this.ctx.drawImage(\n      BASE_SPRITE,\n      this.x + this.canvas.width,\n      this.canvas.height - Base.BASE_SIZE,\n      this.canvas.width,\n      Base.BASE_SIZE\n    );\n  }\n}\n","import { Base } from './Base';\nimport { Sprite } from './Sprite';\ntype ConstructorProps = {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n};\n\nconst BACKGROUND_SPRITE = new Sprite('background.png').sprite;\n\nexport class Background {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  constructor(params: ConstructorProps) {\n    this.canvas = params.canvas;\n    this.ctx = params.ctx;\n  }\n\n  draw() {\n    this.ctx.drawImage(\n      BACKGROUND_SPRITE,\n      0,\n      0,\n      this.canvas.width,\n      this.canvas.height - Base.BASE_SIZE\n    );\n  }\n}\n","import { Base } from './Base';\nimport { Sprite } from './Sprite';\nimport { velocity } from './velocity';\n\ntype ConstructorProps = {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  x: number;\n};\n\nconst PIPEDOWN_SPRITE = new Sprite('pipedown.png').sprite;\nconst PIPEUP_SPRITE = new Sprite('pipeup.png').sprite;\n\nexport class Pipe {\n  public x: number;\n  public width = 70;\n  public height: number;\n\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  public passed = false;\n\n  public static PIPE_DISTANCE = 150;\n  public static PIPE_RANGE = 250;\n\n  constructor(params: ConstructorProps) {\n    this.canvas = params.canvas;\n    this.ctx = params.ctx;\n\n    this.x = params.x;\n\n    this.height = Math.max(\n      Math.random() * this.canvas.height - Base.BASE_SIZE - Pipe.PIPE_DISTANCE * 1.5,\n      200\n    );\n  }\n\n  update() {\n    this.x -= velocity;\n    if (this.x <= -this.canvas.width) this.x = 0;\n  }\n\n  draw() {\n    // top\n    this.ctx.drawImage(\n      PIPEDOWN_SPRITE,\n      0,\n      PIPEDOWN_SPRITE.height - this.height,\n      PIPEDOWN_SPRITE.width,\n      this.height,\n      this.x,\n      0,\n      this.width,\n      this.height\n    );\n\n    // bottom\n    const bottomY = this.height + Pipe.PIPE_DISTANCE;\n    this.ctx.drawImage(\n      PIPEUP_SPRITE,\n      0,\n      0,\n      PIPEUP_SPRITE.width,\n      this.canvas.height - Base.BASE_SIZE - bottomY,\n      this.x,\n      bottomY,\n      this.width,\n      this.canvas.height - Base.BASE_SIZE - bottomY\n    );\n  }\n}\n","import { Base } from './Base';\nimport { Pipe } from './Pipe';\nimport { Sprite } from './Sprite';\nimport { velocity } from './velocity';\nimport { Network } from '../../../neural-box/src';\n\ntype ConstructorProps = {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  brain?: Network;\n};\n\nconst BIRD_SPRITE = new Sprite('bird.png').sprite;\n\nexport class Bird {\n  private score = 0;\n  private x: number = Bird.BIRD_START_POSITION;\n  private y: number;\n  private vy = 0;\n  private rotation = 0;\n  public isDead = false;\n\n  public brain: Network;\n\n  public static BIRD_START_POSITION = 40;\n\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  constructor(params: ConstructorProps) {\n    this.canvas = params.canvas;\n    this.ctx = params.ctx;\n    this.y = this.canvas.height / 2;\n\n    if (params.brain) {\n      this.brain = params.brain;\n    } else {\n      this.brain = new Network({\n        inputLength: 4,\n        outputLength: 1\n      });\n      this.brain.generateFullNetwork();\n    }\n  }\n\n  checkCollision(pipes: Pipe[]) {\n    if (this.isDead) return;\n\n    // Check if we hit the ground\n    if (this.canvas.height - this.y <= Base.BASE_SIZE) {\n      this.isDead = true;\n      this.y = this.canvas.height - Base.BASE_SIZE;\n      return;\n    }\n\n    // Check if we hit the sky\n    if (this.y <= 0) {\n      this.isDead = true;\n      this.y = 0;\n      return;\n    }\n\n    // Check pipe collision\n    for (const pipe of pipes) {\n      if (this.x >= pipe.x && this.x <= pipe.x + pipe.width) {\n        if (this.y <= pipe.height || this.y >= pipe.height + Pipe.PIPE_DISTANCE) {\n          this.isDead = true;\n          return;\n        }\n      }\n    }\n  }\n\n  getFitness() {\n    return this.score;\n  }\n\n  getY() {\n    return this.y;\n  }\n\n  jump() {\n    if (this.isDead) return;\n\n    this.vy = -15;\n    this.rotation = -55;\n  }\n\n  update() {\n    if (this.isDead) {\n      if (this.x > -BIRD_SPRITE.width) this.x -= velocity;\n      return;\n    }\n\n    this.score++;\n    this.vy += 1;\n    this.y += this.vy;\n    this.rotation += 5;\n    if (this.rotation > 90) this.rotation = 90;\n  }\n\n  draw() {\n    this.ctx.save();\n\n    const rotation = this.rotation * (Math.PI / 180);\n    const x = this.x + BIRD_SPRITE.width / 2;\n\n    this.ctx.setTransform(1, 0, 0, 1, x, this.y);\n    this.ctx.rotate(rotation);\n    this.ctx.drawImage(BIRD_SPRITE, -BIRD_SPRITE.width / 2, -BIRD_SPRITE.height / 2);\n\n    this.ctx.restore();\n  }\n}\n","import { Sprite } from './Sprite';\n\ntype ConstructorProps = {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n};\n\nconst SCORES_SPRITES: HTMLImageElement[] = [];\n\nfor (let i = 0; i < 10; ++i) {\n  const sprite = new Sprite(`${i}.png`);\n  SCORES_SPRITES.push(sprite.sprite);\n}\n\nexport class Score {\n  private score = 0;\n\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  constructor(params: ConstructorProps) {\n    this.canvas = params.canvas;\n    this.ctx = params.ctx;\n  }\n\n  getScore() {\n    return this.score;\n  }\n\n  reset() {\n    this.score = 0;\n  }\n\n  increase() {\n    this.score++;\n  }\n\n  draw() {\n    const strScore = this.score.toString();\n    const scoreNumbers = strScore.split('');\n\n    for (let i = 0; i < scoreNumbers.length; ++i) {\n      const number = Number(scoreNumbers[i]);\n      const numberSprite = SCORES_SPRITES[number];\n      this.ctx.drawImage(\n        numberSprite,\n        this.canvas.width / 2 -\n          (numberSprite.width / 2) * scoreNumbers.length +\n          i * numberSprite.width,\n        20\n      );\n    }\n  }\n}\n","import { drawNeuralNetwork, NeatAlgo } from '../../neural-box/src';\nimport { Network } from '../../neural-box/src';\nimport { Background } from './game/Background';\nimport { Base } from './game/Base';\nimport { Bird } from './game/Bird';\nimport { Pipe } from './game/Pipe';\nimport { Score } from './game/Score';\n\nlet BIRDS_COUNT = 50;\nconst FPS = 60;\nlet SPEED = 1;\nlet GAME_CLOCK: NodeJS.Timeout;\n\nconst canvas = document.querySelector('canvas')!;\nconst ctx = canvas.getContext('2d')!;\nconst speedSettings = document.querySelector('#speed-container')!;\nconst birdsCountSettings = document.querySelector('#birds-count-container')!;\nconst generation = document.querySelector('#generation')!;\nconst bestScore = document.querySelector('#best-score')!;\nconst model = document.querySelector('#model') as HTMLTextAreaElement;\nconst loadModelBtn = document.querySelector('#load-btn')!;\nconst loadModelTextarea = document.querySelector('#model-to-load') as HTMLTextAreaElement;\nconst drawing = document.querySelector('#drawing') as HTMLCanvasElement;\n\nconst neat = new NeatAlgo();\nconst background = new Background({\n  canvas,\n  ctx\n});\nconst base = new Base({\n  canvas,\n  ctx\n});\nconst score = new Score({\n  canvas,\n  ctx\n});\nconst pipes: Pipe[] = [];\nconst birds: Bird[] = [];\n\n/**\n * Init / Reset the game\n */\nfunction initGame(bestBirdBrain?: Network) {\n  // Set the generation and best score\n  generation.textContent = String(Number(generation.textContent) + 1);\n  bestScore.textContent = String(Math.max(Number(bestScore.textContent), score.getScore()));\n\n  // Init pipes\n  for (let i = 0; i < canvas.height; i += Pipe.PIPE_RANGE) {\n    const pipe = new Pipe({\n      canvas,\n      ctx,\n      x: canvas.width + i\n    });\n    pipes.push(pipe);\n  }\n\n  const createBird = (brain?: Network) =>\n    new Bird({\n      canvas,\n      ctx,\n      brain\n    });\n\n  // Init birds\n  let numberOfBirds = BIRDS_COUNT;\n  if (bestBirdBrain) {\n    const bird = createBird(bestBirdBrain.clone());\n    birds.push(bird);\n    numberOfBirds -= 1;\n  }\n  for (let i = 0; i < numberOfBirds; ++i) {\n    let brain: Network | undefined = undefined;\n    // we want to generate some random birds too\n    if (bestBirdBrain && i % 10 !== 0) {\n      brain = bestBirdBrain.clone();\n      neat.mutate(brain);\n    }\n    const bird = createBird(brain);\n    birds.push(bird);\n  }\n\n  score.reset();\n}\n\n/**\n * Get the best network\n */\nfunction getBestNetwork() {\n  birds.sort((a, b) => b.getFitness() - a.getFitness());\n  const bestBird = birds[0];\n  return bestBird.brain;\n}\n\n/**\n * Update the best model\n */\nfunction updateBestModel() {\n  const network = getBestNetwork().toJson();\n  model.value = JSON.stringify(network);\n  drawNeuralNetwork(network, drawing);\n}\n\n/**\n * Handle the game\n */\nfunction game() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  // Backgrou drawing\n  background.draw();\n\n  // Handle pipes\n  let removePipe = false;\n  for (const pipe of pipes) {\n    pipe.update();\n    pipe.draw();\n\n    if (!pipe.passed && pipe.x + pipe.width < Bird.BIRD_START_POSITION) {\n      pipe.passed = true;\n      score.increase();\n    }\n\n    if (pipe.x + pipe.width < 0) {\n      removePipe = true;\n      pipes.push(\n        new Pipe({\n          canvas,\n          ctx,\n          x: pipes[pipes.length - 1].x + Pipe.PIPE_RANGE\n        })\n      );\n    }\n  }\n  if (removePipe) pipes.shift();\n\n  // Draw moving base\n  base.update();\n  base.draw();\n\n  // Draw score\n  score.draw();\n\n  // Handle birds\n  let notAllBirdsDead = false;\n  const closerPipe = pipes.find(pipe => pipe.x + pipe.width > Bird.BIRD_START_POSITION)!;\n  for (const bird of birds) {\n    const pipeXDistance = closerPipe.x - Bird.BIRD_START_POSITION;\n    const pipeUpY = closerPipe.height;\n    const pipeBottomY = closerPipe.height + Pipe.PIPE_DISTANCE;\n\n    const output = bird.brain.input([bird.getY(), pipeXDistance, pipeUpY, pipeBottomY])[0];\n    const shouldJump = output > 0.5;\n    if (shouldJump) bird.jump();\n\n    bird.update();\n\n    bird.checkCollision(pipes);\n    if (!bird.isDead) notAllBirdsDead = true;\n\n    bird.draw();\n  }\n\n  updateBestModel();\n\n  // When all birds are dead we reset the game\n  if (!notAllBirdsDead) {\n    const bestNetwork = getBestNetwork();\n\n    pipes.length = 0;\n    birds.length = 0;\n\n    initGame(bestNetwork);\n  }\n}\n\n// Settings\nbirdsCountSettings.addEventListener('click', () => {\n  const selectedBtn = birdsCountSettings.querySelector('input:checked') as HTMLInputElement;\n  BIRDS_COUNT = Number(selectedBtn.value);\n});\n\nspeedSettings.addEventListener('click', () => {\n  const selectedBtn = speedSettings.querySelector('input:checked') as HTMLInputElement;\n  SPEED = Number(selectedBtn.value);\n  clearInterval(GAME_CLOCK);\n  GAME_CLOCK = setInterval(game, 1000 / FPS / SPEED);\n});\n\n// Update model\nloadModelBtn.addEventListener('click', () => {\n  try {\n    const networkJson = JSON.parse(loadModelTextarea.value?.trim());\n    loadModelTextarea.value = '';\n    const network = Network.fromJson(networkJson);\n    pipes.length = 0;\n    birds.length = 0;\n    initGame(network);\n  } catch (e: any) {\n    console.error(e);\n    loadModelTextarea.value = e;\n  }\n});\n\n// Init and start game\ninitGame();\n\nGAME_CLOCK = setInterval(game, 1000 / FPS / SPEED);\n","import { NetworkJson } from '../network/Network';\nimport { NodeType } from '../network/NeuralNode';\n\nexport function drawNeuralNetwork(json: NetworkJson, canvas: HTMLCanvasElement) {\n  const ctx = canvas.getContext('2d')!;\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  const nodePositions: Record<number, { x: number; y: number }> = {};\n\n  const inputNodes = json.nodes.filter(n => n.nodeType === NodeType.INPUT);\n  const biasNodes = json.nodes.filter(n => n.nodeType === NodeType.BIAS);\n  const hiddenNodes = json.nodes.filter(n => n.nodeType === NodeType.HIDDEN);\n  const outputNodes = json.nodes.filter(n => n.nodeType === NodeType.OUTPUT);\n\n  const layers: number[][] = [];\n  layers.push([...inputNodes.map(n => n.id), ...biasNodes.map(n => n.id)]);\n  if (hiddenNodes.length > 0) layers.push(hiddenNodes.map(n => n.id));\n  layers.push(outputNodes.map(n => n.id));\n\n  const paddingX = canvas.width * 0.1;\n  const paddingY = canvas.height * 0.1;\n  const usableWidth = canvas.width - 2 * paddingX;\n  const usableHeight = canvas.height - 2 * paddingY;\n\n  const spacingX = usableWidth / (layers.length - 1);\n  const maxNodes = Math.max(...layers.map(layer => layer.length));\n  const spacingY = maxNodes > 1 ? usableHeight / (maxNodes - 1) : 0;\n\n  const nodeRadius = Math.max(5, Math.min(15, canvas.width / 50));\n  const minLineWidth = 1;\n  const maxLineWidth = Math.max(3, canvas.width / 100);\n\n  layers.forEach((layer, layerIndex) => {\n    const x = paddingX + layerIndex * spacingX;\n    layer.forEach((nodeId, i) => {\n      const y = paddingY + i * spacingY;\n      nodePositions[nodeId] = { x, y };\n    });\n  });\n\n  json.connections.forEach(conn => {\n    if (!conn.enabled) return;\n    const from = nodePositions[conn.fromId];\n    const to = nodePositions[conn.toId];\n    if (!from || !to) return;\n\n    const weight = Math.abs(conn.weight);\n    ctx.strokeStyle = conn.weight > 0 ? 'blue' : 'red';\n    ctx.lineWidth = minLineWidth + weight * (maxLineWidth - minLineWidth);\n    ctx.beginPath();\n    ctx.moveTo(from.x, from.y);\n    ctx.lineTo(to.x, to.y);\n    ctx.stroke();\n  });\n\n  json.nodes.forEach(node => {\n    const pos = nodePositions[node.id];\n    if (!pos) return;\n\n    ctx.fillStyle =\n      node.nodeType === NodeType.BIAS\n        ? 'grey'\n        : node.nodeType === NodeType.HIDDEN\n          ? 'orange'\n          : node.nodeType === NodeType.INPUT\n            ? 'cyan'\n            : 'yellow';\n\n    ctx.beginPath();\n    ctx.arc(pos.x, pos.y, nodeRadius, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = 'black';\n    ctx.stroke();\n  });\n}\n"],"names":["NodeType","NeuralNode","constructor","params","this","output","id","nodeType","layer","BIAS","toJson","clone","randomUniform","min","max","Math","random","defaultMutationsChances","disableConnection","enableConnection","newConnection","newNode","removeNode","weightModification","InnovationNumberManager","getInnovationNumber","fromNodeId","toNodeId","key","innovationHistory","has","get","newInnovationNumber","currentInnovationNumber","set","Map","Connection","enabled","innovationNumber","from","to","weight","_a","_c","_b","weightRange","DEFAULT_WEIGHT_RANGE","_e","_d","fromId","toId","copy","Network","currentNodeId","fitness","connections","nodes","inputLength","outputLength","hiddenLength","length","hiddenLayers","Error","fromJson","json","network","maxId","node","push","connection","find","n","con","map","c","generateFullNetwork","nodesOfPrecedentLayer","bias","i","input","INPUT","hiddenCreatedNodes","j","hidden","HIDDEN","precedentLayerNode","OUTPUT","inputs","inputNodes","outputNodes","inputsToCalculates","inputToReset","nodeDest","contribution","x","exp","removeConnection","index","findIndex","co","splice","filter","conn","addNodeInConnection","connectionToNewNode","connectionFromNewNode","addRandomConnection","attemptCount","maxAttempts","fromIndex","floor","toIndex","some","randomConnection","getWeightRange","getConnections","getNodes","setConnections","setNodes","nodesCopy","connectionsCopy","Sprite","src","sprite","Image","BASE_SPRITE","Base","canvas","ctx","update","width","draw","drawImage","height","BASE_SIZE","BACKGROUND_SPRITE","PIPEDOWN_SPRITE","PIPEUP_SPRITE","Pipe","passed","PIPE_DISTANCE","bottomY","PIPE_RANGE","BIRD_SPRITE","Bird","score","BIRD_START_POSITION","vy","rotation","isDead","y","brain","checkCollision","pipes","pipe","getFitness","getY","jump","save","PI","setTransform","rotate","restore","SCORES_SPRITES","BIRDS_COUNT","GAME_CLOCK","SPEED","document","querySelector","getContext","speedSettings","birdsCountSettings","generation","bestScore","model","loadModelBtn","loadModelTextarea","drawing","neat","mutationsChances","Object","assign","crossover","mutate","rndConnection","minWeight","maxWeight","newWeight","removableNodes","rndNode","noBiasConnections","noBiasDisabledConnections","generateChildrens","networks","numberOfChildrens","background","base","getScore","reset","increase","scoreNumbers","toString","split","number","Number","numberSprite","birds","initGame","bestBirdBrain","textContent","String","createBird","numberOfBirds","bird","getBestNetwork","sort","a","b","updateBestModel","value","JSON","stringify","clearRect","nodePositions","biasNodes","hiddenNodes","layers","paddingX","paddingY","usableWidth","usableHeight","spacingX","maxNodes","spacingY","nodeRadius","maxLineWidth","forEach","layerIndex","nodeId","abs","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","pos","fillStyle","arc","fill","drawNeuralNetwork","game","removePipe","shift","notAllBirdsDead","closerPipe","pipeXDistance","pipeUpY","pipeBottomY","bestNetwork","addEventListener","selectedBtn","clearInterval","setInterval","networkJson","parse","trim","e","console","error"],"mappings":"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"}