{"version":3,"file":"index.js","sources":["../../neural-box/src/utils/randomUniform.ts","../../neural-box/src/neat/NeatAlgo.ts","../../neural-box/src/network/Connection.ts","../../neural-box/src/network/NeuralNode.ts","../../neural-box/src/network/Network.ts","../../neural-box/src/utils/sigmoid.ts","../src/game/Sprite.ts","../src/game/velocity.ts","../src/game/Base.ts","../src/game/Background.ts","../src/game/Pipe.ts","../src/game/Bird.ts","../src/game/Score.ts","../src/index.ts","../../neural-box/src/utils/drawNeuralNetwork.ts"],"sourcesContent":["/**\n * Uniform distribution of a random number in a range\n * @param min\n * @param max\n * @returns\n */\nexport function randomUniform(min: number, max: number): number {\n  return Math.random() * (max - min) + min;\n}\n","import { Network } from '../network/Network';\nimport { randomUniform } from '../utils/randomUniform';\n\ntype ConstructorParams = {\n  mutationsChances?: {\n    newConnection?: number;\n    newNode?: number;\n    weightModification?: number;\n    removeNode?: number;\n    removeConnection?: number;\n    disableConnection?: number;\n    enableConnection?: number;\n  };\n};\n\nconst defaultMutationsChances: Required<ConstructorParams['mutationsChances']> = {\n  disableConnection: 0.1,\n  enableConnection: 0.1,\n  newConnection: 0.1,\n  newNode: 0.1,\n  removeConnection: 0.1,\n  removeNode: 0.1,\n  weightModification: 0.9\n};\n\nexport class NeatAlgo {\n  private mutationsChances: Required<Required<ConstructorParams>['mutationsChances']>;\n\n  constructor(params: ConstructorParams = {}) {\n    this.mutationsChances = Object.assign({}, defaultMutationsChances, params.mutationsChances);\n  }\n\n  crossover() {}\n\n  mutate(network: Network) {\n    const connections = network.getConnections();\n    const nodes = network.getNodes();\n\n    // Weight modification\n    if (Math.random() <= this.mutationsChances.weightModification && connections.length > 0) {\n      const rndConnection = Math.floor(randomUniform(0, connections.length));\n      const [minWeight, maxWeight] = network.getWeightRange();\n      const newWeight = randomUniform(minWeight, maxWeight);\n      connections[rndConnection].weight = newWeight;\n    }\n\n    // New connection\n    if (Math.random() <= this.mutationsChances.newConnection) {\n      network.addRandomConnection();\n    }\n\n    // Remove connection\n    if (Math.random() <= this.mutationsChances.removeConnection && connections.length > 0) {\n      const rndConnection = Math.floor(randomUniform(0, connections.length));\n      network.removeConnection(connections[rndConnection]);\n    }\n\n    // New node\n    if (Math.random() <= this.mutationsChances.newNode && connections.length > 0) {\n      const rndConnection = Math.floor(randomUniform(0, connections.length));\n      network.addNodeInConnection(connections[rndConnection]);\n    }\n\n    // Remove node\n    if (Math.random() <= this.mutationsChances.removeNode && nodes.length > 0) {\n      const rndNode = Math.floor(randomUniform(0, nodes.length));\n      network.removeNode(nodes[rndNode]);\n    }\n\n    // Disable connection\n    if (Math.random() <= this.mutationsChances.disableConnection && connections.length > 0) {\n      const rndConnection = Math.floor(randomUniform(0, connections.length));\n      connections[rndConnection].enabled = false;\n    }\n\n    // Enable connection\n    if (Math.random() <= this.mutationsChances.enableConnection) {\n      const disabledConnections = connections.filter(connection => !connection.enabled);\n      if (disabledConnections.length > 0) {\n        const rndConnection = Math.floor(randomUniform(0, disabledConnections.length));\n        disabledConnections[rndConnection].enabled = true;\n      }\n    }\n  }\n\n  generateChildrens(networks: Network[], numberOfChildrens: number): Network[] {\n    const childrens: Network[] = [];\n\n    for (let i = 0; i < numberOfChildrens; ++i) {\n      // TODO\n    }\n\n    return childrens;\n  }\n}\n","import { randomUniform } from '../utils/randomUniform';\nimport type { NeuralNode } from './NeuralNode';\n\ntype ConstructorProps = {\n  from: NeuralNode;\n  to: NeuralNode;\n  weight?: number;\n  weightRange?: [number, number];\n};\n\nexport type ConenctionJson = {\n  innovationNumber: number;\n  fromId: number;\n  toId: number;\n  weight: number;\n  enabled: boolean;\n};\n\nclass InnovationNumberManager {\n  private static currentInnovationNumber = 0;\n  private static innovationHistory: Map<string, number> = new Map();\n\n  static getInnovationNumber(fromNodeId: number, toNodeId: number): number {\n    const key = `${fromNodeId}-${toNodeId}`;\n\n    if (this.innovationHistory.has(key)) {\n      return this.innovationHistory.get(key)!;\n    }\n\n    const newInnovationNumber = this.currentInnovationNumber++;\n    this.innovationHistory.set(key, newInnovationNumber);\n    return newInnovationNumber;\n  }\n}\n\nexport class Connection {\n  public innovationNumber: number;\n\n  public from: NeuralNode;\n  public to: NeuralNode;\n  public weight: number;\n  public enabled = true;\n\n  public static DEFAULT_WEIGHT_RANGE = [-0.5, 0.5];\n\n  constructor(params: ConstructorProps) {\n    this.innovationNumber = InnovationNumberManager.getInnovationNumber(\n      params.from.id,\n      params.to.id\n    );\n    this.from = params.from;\n    this.to = params.to;\n    this.weight =\n      params.weight ??\n      randomUniform(\n        params.weightRange?.[0] ?? Connection.DEFAULT_WEIGHT_RANGE[0],\n        params.weightRange?.[1] ?? Connection.DEFAULT_WEIGHT_RANGE[1]\n      );\n  }\n\n  toJson(): ConenctionJson {\n    return {\n      innovationNumber: this.innovationNumber,\n      enabled: this.enabled,\n      fromId: this.from.id,\n      toId: this.to.id,\n      weight: this.weight\n    };\n  }\n\n  clone() {\n    const copy = new Connection({\n      from: this.from,\n      to: this.to,\n      weight: this.weight\n    });\n    copy.enabled = this.enabled;\n    return copy;\n  }\n}\n","export enum NodeType {\n  HIDDEN,\n  INPUT,\n  OUTPUT,\n  BIAS\n}\n\nexport type NeuralNodeJson = {\n  id: number;\n  nodeType: NodeType;\n};\n\ntype ConstructorProps = {\n  id: number;\n  nodeType: NodeType;\n};\n\nexport class NeuralNode {\n  public id: number;\n  public output = 0;\n  public nodeType: NodeType;\n\n  constructor(params: ConstructorProps) {\n    this.id = params.id;\n    this.nodeType = params.nodeType;\n    if (this.nodeType === NodeType.BIAS) this.output = 1;\n  }\n\n  toJson(): NeuralNodeJson {\n    return {\n      id: this.id,\n      nodeType: this.nodeType\n    };\n  }\n\n  clone() {\n    const copy = new NeuralNode({\n      id: this.id,\n      nodeType: this.nodeType\n    });\n    return copy;\n  }\n}\n","import { randomUniform } from '../utils/randomUniform';\nimport { sigmoid } from '../utils/sigmoid';\nimport { ConenctionJson, Connection } from './Connection';\nimport { NeuralNode, NeuralNodeJson, NodeType } from './NeuralNode';\n\nexport type NetworkJson = {\n  inputLength: number;\n  outputLength: number;\n  hiddenLength: number[];\n  hiddenLayers: number;\n  weightRange?: [number, number];\n\n  connections: ConenctionJson[];\n  nodes: NeuralNodeJson[];\n};\n\ntype ConstructorProps = {\n  inputLength: number;\n  outputLength: number;\n  hiddenLength?: number[];\n  hiddenLayers?: number;\n\n  weightRange?: [number, number];\n};\n\nexport class Network {\n  private currentNodeId = 0;\n\n  public fitness: number = 0;\n\n  private inputLength: number;\n  private outputLength: number;\n  private hiddenLength: number[];\n  private hiddenLayers: number;\n\n  private weightRange: ConstructorProps['weightRange'];\n\n  public connections: Connection[] = [];\n  public nodes: NeuralNode[] = [];\n\n  constructor(params: ConstructorProps) {\n    this.inputLength = params.inputLength;\n    this.outputLength = params.outputLength;\n\n    this.weightRange = params.weightRange;\n\n    if (params.hiddenLength && params.hiddenLength.length !== params.hiddenLayers) {\n      throw new Error(\n        `Invalide parameter \"hiddenLength\": ${params.hiddenLength.length} (should be an array of the same size as \"hiddenLayers\": ${params.hiddenLayers}).`\n      );\n    }\n\n    this.hiddenLayers = params.hiddenLayers ?? 0;\n    this.hiddenLength = params.hiddenLength ?? [];\n  }\n\n  static fromJson(json: NetworkJson): Network {\n    const network = new Network({\n      inputLength: json.inputLength,\n      outputLength: json.outputLength,\n      hiddenLayers: json.hiddenLayers,\n      hiddenLength: json.hiddenLength,\n      weightRange: json.weightRange\n    });\n\n    for (const node of json.nodes) {\n      network.nodes.push(\n        new NeuralNode({\n          id: node.id,\n          nodeType: node.nodeType\n        })\n      );\n    }\n\n    for (const connection of json.connections) {\n      const from = network.nodes.find(n => n.id === connection.fromId)!;\n      const to = network.nodes.find(n => n.id === connection.toId)!;\n      const con = new Connection({\n        from,\n        to,\n        weight: connection.weight,\n        weightRange: json.weightRange\n      });\n      network.connections.push(con);\n    }\n\n    return network;\n  }\n\n  toJson(): NetworkJson {\n    return {\n      connections: this.connections.map(c => c.toJson()),\n      hiddenLayers: this.hiddenLayers,\n      hiddenLength: this.hiddenLength,\n      inputLength: this.inputLength,\n      nodes: this.nodes.map(n => n.toJson()),\n      outputLength: this.outputLength,\n      weightRange: this.weightRange\n    };\n  }\n\n  /**\n   * Generate the full network with all connections and all nodes\n   */\n  generateFullNetwork() {\n    let nodesOfPrecedentLayer: NeuralNode[] = [];\n\n    // Input bias\n    const bias = new NeuralNode({\n      id: ++this.currentNodeId,\n      nodeType: NodeType.BIAS\n    });\n    this.nodes.push(bias);\n    nodesOfPrecedentLayer.push(bias);\n\n    // Inputs\n    for (let i = 0; i < this.inputLength; ++i) {\n      const input = new NeuralNode({\n        id: ++this.currentNodeId,\n        nodeType: NodeType.INPUT\n      });\n      nodesOfPrecedentLayer.push(input);\n      this.nodes.push(input);\n    }\n\n    for (let i = 0; i < this.hiddenLayers; ++i) {\n      const hiddenLength = this.hiddenLength[i];\n      // Hidden bias\n      const bias = new NeuralNode({\n        id: ++this.currentNodeId,\n        nodeType: NodeType.BIAS\n      });\n      const hiddenCreatedNodes: NeuralNode[] = [bias];\n\n      for (let j = 0; j < hiddenLength; ++j) {\n        const hidden = new NeuralNode({\n          id: ++this.currentNodeId,\n          nodeType: NodeType.HIDDEN\n        });\n\n        // We create the connection with the precedents nodes\n        for (const precedentLayerNode of nodesOfPrecedentLayer) {\n          const connection = new Connection({\n            from: precedentLayerNode,\n            to: hidden,\n            weightRange: this.weightRange\n          });\n          this.connections.push(connection);\n        }\n\n        hiddenCreatedNodes.push(hidden);\n        this.nodes.push(hidden);\n      }\n\n      nodesOfPrecedentLayer = hiddenCreatedNodes;\n    }\n\n    for (let i = 0; i < this.outputLength; ++i) {\n      const output = new NeuralNode({\n        id: ++this.currentNodeId,\n        nodeType: NodeType.OUTPUT\n      });\n\n      // We create the connection with the precedents nodes\n      for (const precedentLayerNode of nodesOfPrecedentLayer) {\n        const connection = new Connection({\n          from: precedentLayerNode,\n          to: output,\n          weightRange: this.weightRange\n        });\n        this.connections.push(connection);\n      }\n\n      this.nodes.push(output);\n    }\n  }\n\n  /**\n   * Calculate the output for a specific input\n   * @param inputs\n   * @returns\n   */\n  input(inputs: number[]): number[] {\n    if (inputs.length !== this.inputLength) {\n      throw new Error('Number of inputs must match the number of \"inputLength\".');\n    }\n\n    const inputNodes = this.nodes.filter(node => node.nodeType === NodeType.INPUT);\n    const outputNodes = this.nodes.filter(node => node.nodeType === NodeType.OUTPUT);\n\n    const inputsToReset = this.nodes.filter(\n      node => node.nodeType !== NodeType.INPUT && node.nodeType !== NodeType.BIAS\n    );\n    const noneInputNodes = this.nodes.filter(node => node.nodeType !== NodeType.INPUT);\n\n    // We reset the hiddens/output nodes\n    for (const inputToReset of inputsToReset) {\n      inputToReset.output = 0;\n    }\n\n    // We set the inputs node with the correct input value\n    for (let i = 0; i < inputNodes.length; ++i) {\n      inputNodes[i].output = inputs[i];\n    }\n\n    // For each connection we accumulate their contribution to the neuron\n    // A neuron can have multiple entry connection this is why its an addition\n    for (const connection of this.connections) {\n      const nodeDest = connection.to;\n      const contribution = connection.from.output * connection.weight;\n      nodeDest.output += contribution;\n    }\n\n    // After we have accumulate the connection contribution to the neuron we add the bias\n    // Then we apply the transformation function (expl: sigmoid)\n    for (const noneInputNode of noneInputNodes) {\n      noneInputNode.output = sigmoid(noneInputNode.output);\n    }\n\n    return outputNodes.map(node => node.output);\n  }\n\n  /**\n   * Remove a specific connection\n   * @param connection\n   */\n  removeConnection(connection: Connection) {\n    const index = this.connections.findIndex(co => connection === co);\n    if (index !== -1) this.connections.splice(index, 1);\n  }\n\n  /**\n   * Remove a node\n   * @param node\n   */\n  removeNode(node: NeuralNode) {\n    this.nodes = this.nodes.filter(n => n !== node);\n    this.connections = this.connections.filter(conn => conn.from !== node && conn.to !== node);\n  }\n\n  /**\n   * Add a node in between a connection\n   * @param connection\n   */\n  addNodeInConnection(connection: Connection) {\n    this.removeConnection(connection);\n\n    const newNode = new NeuralNode({\n      id: ++this.currentNodeId,\n      nodeType: NodeType.HIDDEN\n    });\n\n    this.nodes.push(newNode);\n\n    const connectionToNewNode = new Connection({\n      from: connection.from,\n      to: newNode,\n      weightRange: this.weightRange\n    });\n\n    const connectionFromNewNode = new Connection({\n      from: newNode,\n      to: connection.to,\n      weightRange: this.weightRange\n    });\n\n    this.connections.push(connectionToNewNode, connectionFromNewNode);\n  }\n\n  /**\n   * Add a random connection\n   * @returns\n   */\n  addRandomConnection() {\n    let attemptCount = 0;\n    const maxAttempts = this.nodes.length * this.nodes.length; // A simple upper limit based on the number of possible connections\n\n    while (attemptCount < maxAttempts) {\n      const fromIndex = Math.floor(randomUniform(0, this.nodes.length));\n      const toIndex = Math.floor(randomUniform(0, this.nodes.length));\n\n      if (fromIndex === toIndex) {\n        attemptCount++;\n        continue;\n      }\n\n      const randomConnection = new Connection({\n        from: this.nodes[fromIndex],\n        to: this.nodes[toIndex],\n        weightRange: this.weightRange\n      });\n\n      const exists = this.connections.some(\n        connection =>\n          connection.from === randomConnection.from && connection.to === randomConnection.to\n      );\n\n      if (!exists) {\n        this.connections.push(randomConnection); // Assuming this.connections is the array holding all connections\n        return randomConnection;\n      }\n\n      attemptCount++;\n    }\n\n    throw new Error('Failed to add a new connection: too many attempts.');\n  }\n\n  getWeightRange() {\n    return this.weightRange ?? Connection.DEFAULT_WEIGHT_RANGE;\n  }\n\n  getConnections() {\n    return this.connections;\n  }\n\n  getNodes() {\n    return this.nodes;\n  }\n\n  setConnections(connections: Connection[]) {\n    this.connections = connections;\n  }\n\n  setNodes(nodes: NeuralNode[]) {\n    this.nodes = nodes;\n  }\n\n  /**\n   * Clone the current network\n   * @returns\n   */\n  clone() {\n    const copy = new Network({\n      inputLength: this.inputLength,\n      outputLength: this.outputLength,\n      hiddenLayers: this.hiddenLayers,\n      hiddenLength: this.hiddenLength,\n      weightRange: this.weightRange\n    });\n\n    const nodesCopy = [...this.getNodes().map(node => node.clone())];\n    copy.setNodes(nodesCopy);\n\n    const connectionsCopy = [\n      ...this.getConnections().map(connection => {\n        const clone = connection.clone();\n        clone.from = nodesCopy.find(n => n.id === clone.from.id)!;\n        clone.to = nodesCopy.find(n => n.id === clone.to.id)!;\n        return clone;\n      })\n    ];\n    copy.setConnections(connectionsCopy);\n\n    return copy;\n  }\n}\n","/**\n * Sigmoid function to turn any number into the range from 0 to 1\n * Usefull for probability\n * @param x\n * @returns\n */\nexport function sigmoid(x: number): number {\n  return 1 / (1 + Math.exp(-x));\n}\n","export class Sprite {\n  public sprite: HTMLImageElement = new Image();\n\n  constructor(src: string) {\n    this.sprite.src = `./sprites/${src}`;\n  }\n}\n","export const velocity = 4;\n","import { Sprite } from './Sprite';\nimport { velocity } from './velocity';\n\ntype ConstructorProps = {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n};\n\nconst BASE_SPRITE = new Sprite('base.png').sprite;\n\nexport class Base {\n  private x = 0;\n\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  public static BASE_SIZE = 100;\n\n  constructor(params: ConstructorProps) {\n    this.canvas = params.canvas;\n    this.ctx = params.ctx;\n  }\n\n  update() {\n    this.x -= velocity;\n    if (this.x <= -this.canvas.width) this.x = 0;\n  }\n\n  draw() {\n    this.ctx.drawImage(\n      BASE_SPRITE,\n      this.x,\n      this.canvas.height - Base.BASE_SIZE,\n      this.canvas.width,\n      Base.BASE_SIZE\n    );\n\n    this.ctx.drawImage(\n      BASE_SPRITE,\n      this.x + this.canvas.width,\n      this.canvas.height - Base.BASE_SIZE,\n      this.canvas.width,\n      Base.BASE_SIZE\n    );\n  }\n}\n","import { Base } from './Base';\nimport { Sprite } from './Sprite';\ntype ConstructorProps = {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n};\n\nconst BACKGROUND_SPRITE = new Sprite('background.png').sprite;\n\nexport class Background {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  constructor(params: ConstructorProps) {\n    this.canvas = params.canvas;\n    this.ctx = params.ctx;\n  }\n\n  draw() {\n    this.ctx.drawImage(\n      BACKGROUND_SPRITE,\n      0,\n      0,\n      this.canvas.width,\n      this.canvas.height - Base.BASE_SIZE\n    );\n  }\n}\n","import { Base } from './Base';\nimport { Sprite } from './Sprite';\nimport { velocity } from './velocity';\n\ntype ConstructorProps = {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  x: number;\n};\n\nconst PIPEDOWN_SPRITE = new Sprite('pipedown.png').sprite;\nconst PIPEUP_SPRITE = new Sprite('pipeup.png').sprite;\n\nexport class Pipe {\n  public x: number;\n  public width = 70;\n  public height: number;\n\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  public passed = false;\n\n  public static PIPE_DISTANCE = 150;\n  public static PIPE_RANGE = 250;\n\n  constructor(params: ConstructorProps) {\n    this.canvas = params.canvas;\n    this.ctx = params.ctx;\n\n    this.x = params.x;\n\n    this.height = Math.max(\n      Math.random() * this.canvas.height - Base.BASE_SIZE - Pipe.PIPE_DISTANCE * 1.5,\n      200\n    );\n  }\n\n  update() {\n    this.x -= velocity;\n    if (this.x <= -this.canvas.width) this.x = 0;\n  }\n\n  draw() {\n    // top\n    this.ctx.drawImage(\n      PIPEDOWN_SPRITE,\n      0,\n      PIPEDOWN_SPRITE.height - this.height,\n      PIPEDOWN_SPRITE.width,\n      this.height,\n      this.x,\n      0,\n      this.width,\n      this.height\n    );\n\n    // bottom\n    const bottomY = this.height + Pipe.PIPE_DISTANCE;\n    this.ctx.drawImage(\n      PIPEUP_SPRITE,\n      0,\n      0,\n      PIPEUP_SPRITE.width,\n      this.canvas.height - Base.BASE_SIZE - bottomY,\n      this.x,\n      bottomY,\n      this.width,\n      this.canvas.height - Base.BASE_SIZE - bottomY\n    );\n  }\n}\n","import { Base } from './Base';\nimport { Pipe } from './Pipe';\nimport { Sprite } from './Sprite';\nimport { velocity } from './velocity';\nimport { Network } from '../../../neural-box/src';\n\ntype ConstructorProps = {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  brain?: Network;\n};\n\nconst BIRD_SPRITE = new Sprite('bird.png').sprite;\n\nexport class Bird {\n  private score = 0;\n  private x: number = Bird.BIRD_START_POSITION;\n  private y: number;\n  private vy = 0;\n  private rotation = 0;\n  public isDead = false;\n\n  public brain: Network;\n\n  public static BIRD_START_POSITION = 40;\n\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  constructor(params: ConstructorProps) {\n    this.canvas = params.canvas;\n    this.ctx = params.ctx;\n    this.y = this.canvas.height / 2;\n\n    if (params.brain) {\n      this.brain = params.brain;\n    } else {\n      this.brain = new Network({\n        inputLength: 4,\n        outputLength: 1\n      });\n      this.brain.generateFullNetwork();\n    }\n  }\n\n  checkCollision(pipes: Pipe[]) {\n    if (this.isDead) return;\n\n    // Check if we hit the ground\n    if (this.canvas.height - this.y <= Base.BASE_SIZE) {\n      this.isDead = true;\n      this.y = this.canvas.height - Base.BASE_SIZE;\n      return;\n    }\n\n    // Check if we hit the sky\n    if (this.y <= 0) {\n      this.isDead = true;\n      this.y = 0;\n      return;\n    }\n\n    // Check pipe collision\n    for (const pipe of pipes) {\n      if (this.x >= pipe.x && this.x <= pipe.x + pipe.width) {\n        if (this.y <= pipe.height || this.y >= pipe.height + Pipe.PIPE_DISTANCE) {\n          this.isDead = true;\n          return;\n        }\n      }\n    }\n  }\n\n  getFitness() {\n    return this.score;\n  }\n\n  getY() {\n    return this.y;\n  }\n\n  jump() {\n    if (this.isDead) return;\n\n    this.vy = -15;\n    this.rotation = -55;\n  }\n\n  update() {\n    if (this.isDead) {\n      if (this.x > -BIRD_SPRITE.width) this.x -= velocity;\n      return;\n    }\n\n    this.score++;\n    this.vy += 1;\n    this.y += this.vy;\n    this.rotation += 5;\n    if (this.rotation > 90) this.rotation = 90;\n  }\n\n  draw() {\n    this.ctx.save();\n\n    const rotation = this.rotation * (Math.PI / 180);\n    const x = this.x + BIRD_SPRITE.width / 2;\n\n    this.ctx.setTransform(1, 0, 0, 1, x, this.y);\n    this.ctx.rotate(rotation);\n    this.ctx.drawImage(BIRD_SPRITE, -BIRD_SPRITE.width / 2, -BIRD_SPRITE.height / 2);\n\n    this.ctx.restore();\n  }\n}\n","import { Sprite } from './Sprite';\n\ntype ConstructorProps = {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n};\n\nconst SCORES_SPRITES: HTMLImageElement[] = [];\n\nfor (let i = 0; i < 10; ++i) {\n  const sprite = new Sprite(`${i}.png`);\n  SCORES_SPRITES.push(sprite.sprite);\n}\n\nexport class Score {\n  private score = 0;\n\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n\n  constructor(params: ConstructorProps) {\n    this.canvas = params.canvas;\n    this.ctx = params.ctx;\n  }\n\n  getScore() {\n    return this.score;\n  }\n\n  reset() {\n    this.score = 0;\n  }\n\n  increase() {\n    this.score++;\n  }\n\n  draw() {\n    const strScore = this.score.toString();\n    const scoreNumbers = strScore.split('');\n\n    for (let i = 0; i < scoreNumbers.length; ++i) {\n      const number = Number(scoreNumbers[i]);\n      const numberSprite = SCORES_SPRITES[number];\n      this.ctx.drawImage(\n        numberSprite,\n        this.canvas.width / 2 -\n          (numberSprite.width / 2) * scoreNumbers.length +\n          i * numberSprite.width,\n        20\n      );\n    }\n  }\n}\n","import { drawNeuralNetwork, NeatAlgo } from '../../neural-box/src';\nimport { Network } from '../../neural-box/src';\nimport { Background } from './game/Background';\nimport { Base } from './game/Base';\nimport { Bird } from './game/Bird';\nimport { Pipe } from './game/Pipe';\nimport { Score } from './game/Score';\n\nlet BIRDS_COUNT = 50;\nconst FPS = 60;\nlet SPEED = 1;\nlet GAME_CLOCK: NodeJS.Timeout;\n\nconst canvas = document.querySelector('canvas')!;\nconst ctx = canvas.getContext('2d')!;\nconst speedSettings = document.querySelector('#speed-container')!;\nconst birdsCountSettings = document.querySelector('#birds-count-container')!;\nconst generation = document.querySelector('#generation')!;\nconst bestScore = document.querySelector('#best-score')!;\nconst model = document.querySelector('#model') as HTMLTextAreaElement;\nconst loadModelBtn = document.querySelector('#load-btn')!;\nconst loadModelTextarea = document.querySelector('#model-to-load') as HTMLTextAreaElement;\nconst drawing = document.querySelector('#drawing') as HTMLCanvasElement;\n\nconst neat = new NeatAlgo();\nconst background = new Background({\n  canvas,\n  ctx\n});\nconst base = new Base({\n  canvas,\n  ctx\n});\nconst score = new Score({\n  canvas,\n  ctx\n});\nconst pipes: Pipe[] = [];\nconst birds: Bird[] = [];\n\n/**\n * Init / Reset the game\n */\nfunction initGame(bestBirdBrain?: Network) {\n  // Set the generation and best score\n  generation.textContent = String(Number(generation.textContent) + 1);\n  bestScore.textContent = String(Math.max(Number(bestScore.textContent), score.getScore()));\n\n  // Init pipes\n  for (let i = 0; i < canvas.height; i += Pipe.PIPE_RANGE) {\n    const pipe = new Pipe({\n      canvas,\n      ctx,\n      x: canvas.width + i\n    });\n    pipes.push(pipe);\n  }\n\n  const createBird = (brain?: Network) =>\n    new Bird({\n      canvas,\n      ctx,\n      brain\n    });\n\n  // Init birds\n  let numberOfBirds = BIRDS_COUNT;\n  if (bestBirdBrain) {\n    const bird = createBird(bestBirdBrain.clone());\n    birds.push(bird);\n    numberOfBirds -= 1;\n  }\n  for (let i = 0; i < numberOfBirds; ++i) {\n    let brain: Network | undefined = undefined;\n    // we want to generate some random birds too\n    if (bestBirdBrain && i % 10 !== 0) {\n      brain = bestBirdBrain.clone();\n      neat.mutate(brain);\n    }\n    const bird = createBird(brain);\n    birds.push(bird);\n  }\n\n  score.reset();\n}\n\n/**\n * Get the best network\n */\nfunction getBestNetwork() {\n  birds.sort((a, b) => b.getFitness() - a.getFitness());\n  const bestBird = birds[0];\n  return bestBird.brain;\n}\n\n/**\n * Update the best model\n */\nfunction updateBestModel() {\n  const network = getBestNetwork().toJson();\n  model.value = JSON.stringify(network);\n  drawNeuralNetwork(network, drawing);\n}\n\n/**\n * Handle the game\n */\nfunction game() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  // Backgrou drawing\n  background.draw();\n\n  // Handle pipes\n  let removePipe = false;\n  for (const pipe of pipes) {\n    pipe.update();\n    pipe.draw();\n\n    if (!pipe.passed && pipe.x + pipe.width < Bird.BIRD_START_POSITION) {\n      pipe.passed = true;\n      score.increase();\n    }\n\n    if (pipe.x + pipe.width < 0) {\n      removePipe = true;\n      pipes.push(\n        new Pipe({\n          canvas,\n          ctx,\n          x: pipes[pipes.length - 1].x + Pipe.PIPE_RANGE\n        })\n      );\n    }\n  }\n  if (removePipe) pipes.shift();\n\n  // Draw moving base\n  base.update();\n  base.draw();\n\n  // Draw score\n  score.draw();\n\n  // Handle birds\n  let notAllBirdsDead = false;\n  const closerPipe = pipes.find(pipe => pipe.x + pipe.width > Bird.BIRD_START_POSITION)!;\n  for (const bird of birds) {\n    const pipeXDistance = closerPipe.x - Bird.BIRD_START_POSITION;\n    const pipeUpY = closerPipe.height;\n    const pipeBottomY = closerPipe.height + Pipe.PIPE_DISTANCE;\n\n    const output = bird.brain.input([bird.getY(), pipeXDistance, pipeUpY, pipeBottomY])[0];\n    const shouldJump = output > 0.5;\n    if (shouldJump) bird.jump();\n\n    bird.update();\n\n    bird.checkCollision(pipes);\n    if (!bird.isDead) notAllBirdsDead = true;\n\n    bird.draw();\n  }\n\n  updateBestModel();\n\n  // When all birds are dead we reset the game\n  if (!notAllBirdsDead) {\n    const bestNetwork = getBestNetwork();\n\n    pipes.length = 0;\n    birds.length = 0;\n\n    initGame(bestNetwork);\n  }\n}\n\n// Settings\nbirdsCountSettings.addEventListener('click', () => {\n  const selectedBtn = birdsCountSettings.querySelector('input:checked') as HTMLInputElement;\n  BIRDS_COUNT = Number(selectedBtn.value);\n});\n\nspeedSettings.addEventListener('click', () => {\n  const selectedBtn = speedSettings.querySelector('input:checked') as HTMLInputElement;\n  SPEED = Number(selectedBtn.value);\n  clearInterval(GAME_CLOCK);\n  GAME_CLOCK = setInterval(game, 1000 / FPS / SPEED);\n});\n\n// Update model\nloadModelBtn.addEventListener('click', () => {\n  try {\n    const networkJson = JSON.parse(loadModelTextarea.value);\n    loadModelTextarea.value = '';\n    const network = Network.fromJson(networkJson);\n    pipes.length = 0;\n    birds.length = 0;\n    initGame(network);\n  } catch (e: any) {\n    console.error(e);\n    loadModelTextarea.value = e;\n  }\n});\n\n// Init and start game\ninitGame();\n\nGAME_CLOCK = setInterval(game, 1000 / FPS / SPEED);\n","import { NetworkJson } from '../network/Network';\nimport { NodeType } from '../network/NeuralNode';\n\nexport function drawNeuralNetwork(json: NetworkJson, canvas: HTMLCanvasElement) {\n  const ctx = canvas.getContext('2d')!;\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  const nodePositions: Record<number, { x: number; y: number }> = {};\n\n  const layers: number[][] = [];\n  const inputNodes = json.nodes.filter(n => n.nodeType === 1);\n  const hiddenNodes = json.nodes.filter(n => n.nodeType === 3);\n  const outputNodes = json.nodes.filter(n => n.nodeType === 2);\n\n  layers.push(inputNodes.map(n => n.id));\n  if (hiddenNodes.length > 0) layers.push(hiddenNodes.map(n => n.id));\n  layers.push(outputNodes.map(n => n.id));\n\n  const paddingX = canvas.width * 0.1; // Marge de 10% à gauche et à droite\n  const paddingY = canvas.height * 0.1; // Marge  10% en haut et en bas\n  const usableWidth = canvas.width - 2 * paddingX;\n  const usableHeight = canvas.height - 2 * paddingY;\n\n  const spacingX = usableWidth / (layers.length - 1);\n  const maxNodes = Math.max(...layers.map(layer => layer.length));\n  const spacingY = maxNodes > 1 ? usableHeight / (maxNodes - 1) : 0;\n\n  const nodeRadius = Math.max(5, Math.min(15, canvas.width / 50)); // Taille adaptative des nœuds\n  const minLineWidth = 1;\n  const maxLineWidth = Math.max(3, canvas.width / 100); // Épaisseur max des connexions\n\n  layers.forEach((layer, layerIndex) => {\n    const x = paddingX + layerIndex * spacingX;\n    layer.forEach((nodeId, i) => {\n      const y = paddingY + i * spacingY;\n      nodePositions[nodeId] = { x, y };\n    });\n  });\n\n  json.connections.forEach(conn => {\n    if (!conn.enabled) return;\n    const from = nodePositions[conn.fromId];\n    const to = nodePositions[conn.toId];\n    if (!from || !to) return;\n\n    const weight = Math.abs(conn.weight);\n    ctx.strokeStyle = conn.weight > 0 ? 'blue' : 'red';\n    ctx.lineWidth = minLineWidth + weight * (maxLineWidth - minLineWidth);\n    ctx.beginPath();\n    ctx.moveTo(from.x, from.y);\n    ctx.lineTo(to.x, to.y);\n    ctx.stroke();\n  });\n\n  json.nodes.forEach(node => {\n    const pos = nodePositions[node.id];\n    if (!pos) return;\n\n    ctx.fillStyle =\n      node.nodeType === NodeType.BIAS\n        ? 'grey'\n        : node.nodeType === NodeType.HIDDEN\n          ? 'orange'\n          : node.nodeType === NodeType.INPUT\n            ? 'cyan'\n            : 'yellow';\n    ctx.beginPath();\n    ctx.arc(pos.x, pos.y, nodeRadius, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = 'black';\n    ctx.stroke();\n  });\n}\n"],"names":["randomUniform","min","max","Math","random","defaultMutationsChances","disableConnection","enableConnection","newConnection","newNode","removeConnection","removeNode","weightModification","InnovationNumberManager","getInnovationNumber","fromNodeId","toNodeId","key","this","innovationHistory","has","get","newInnovationNumber","currentInnovationNumber","set","Map","Connection","constructor","params","enabled","innovationNumber","from","id","to","weight","_a","_c","_b","weightRange","DEFAULT_WEIGHT_RANGE","_e","_d","toJson","fromId","toId","clone","copy","NodeType","NeuralNode","output","nodeType","BIAS","Network","currentNodeId","fitness","connections","nodes","inputLength","outputLength","hiddenLength","length","hiddenLayers","Error","fromJson","json","network","node","push","connection","find","n","con","map","c","generateFullNetwork","nodesOfPrecedentLayer","bias","i","input","INPUT","hiddenCreatedNodes","j","hidden","HIDDEN","precedentLayerNode","OUTPUT","inputs","inputNodes","filter","outputNodes","inputsToReset","noneInputNodes","inputToReset","nodeDest","contribution","noneInputNode","x","exp","index","findIndex","co","splice","conn","addNodeInConnection","connectionToNewNode","connectionFromNewNode","addRandomConnection","attemptCount","maxAttempts","fromIndex","floor","toIndex","randomConnection","some","getWeightRange","getConnections","getNodes","setConnections","setNodes","nodesCopy","connectionsCopy","Sprite","src","sprite","Image","BASE_SPRITE","Base","canvas","ctx","update","width","draw","drawImage","height","BASE_SIZE","BACKGROUND_SPRITE","PIPEDOWN_SPRITE","PIPEUP_SPRITE","Pipe","passed","PIPE_DISTANCE","bottomY","PIPE_RANGE","BIRD_SPRITE","Bird","score","BIRD_START_POSITION","vy","rotation","isDead","y","brain","checkCollision","pipes","pipe","getFitness","getY","jump","save","PI","setTransform","rotate","restore","SCORES_SPRITES","BIRDS_COUNT","GAME_CLOCK","SPEED","document","querySelector","getContext","speedSettings","birdsCountSettings","generation","bestScore","model","loadModelBtn","loadModelTextarea","drawing","neat","mutationsChances","Object","assign","crossover","mutate","rndConnection","minWeight","maxWeight","newWeight","rndNode","disabledConnections","generateChildrens","networks","numberOfChildrens","background","base","getScore","reset","increase","scoreNumbers","toString","split","number","Number","numberSprite","birds","initGame","bestBirdBrain","textContent","String","createBird","numberOfBirds","bird","getBestNetwork","sort","a","b","updateBestModel","value","JSON","stringify","clearRect","nodePositions","layers","hiddenNodes","paddingX","paddingY","usableWidth","usableHeight","spacingX","maxNodes","layer","spacingY","nodeRadius","maxLineWidth","forEach","layerIndex","nodeId","abs","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","pos","fillStyle","arc","fill","drawNeuralNetwork","game","removePipe","shift","notAllBirdsDead","closerPipe","pipeXDistance","pipeUpY","pipeBottomY","bestNetwork","addEventListener","selectedBtn","clearInterval","setInterval","networkJson","parse","e","console","error"],"mappings":"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"}